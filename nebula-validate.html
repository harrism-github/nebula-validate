<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">
<link rel="import" href="validate.html">

<script>
(function() {
  'use strict'

  // symbols for private members
  const onPropsChanged = Symbol()
  const timer = Symbol()

  // symbols for protected members
  const observe = Symbol.for('Nebula.ElementMixin.observe')
  const debounce = Symbol.for('Nebula.ElementMixin.debounce')
  const fire = Symbol.for('Nebula.ElementMixin.fire')

  /**
   * Validate forms and data with Validate.js
   */
  class NebulaValidate extends Nebula.ElementMixin(Polymer.Element) {

    /**
     * Gets the custom element name.
     * @type {string}
     */
    static get is() { return 'nebula-validate' }

    /**
     * Gets the property definitions for data binding.
     * @type {Object}
     * @property {Object} constraints - The constraints used to validate the data.
     * @property {Object} data - The data to validate against the constraints.
     * @property {boolean} autoValidate - Indicates if data is validated when changed.
     * @property {number} delay - A debounce value to delay auto validation when the data is changed.
     * @property {string} format - The format option for errors (grouped, flat or detailed).
     * @property {Object} errors - The validation results; an object keyed by field (if format is grouped), otherwise an array.
     */
    static get properties() {
      return {
        constraints: {
          type: Object,
        },
        data: {
          type: Object,
        },
        autoValidate: {
          type: Boolean,
          value: false
        },
        delay: {
          type: Number,
          value: 0
        },
        format: {
          type: String,
          value: 'grouped'
        },
        errors: {
          type: Object,
          notify: true
        }
      }
    }

    /**
     * Lifecycle callback invoked when a new element instance is created.
     */
    constructor() {
      super()
      this[observe]('constraints.*, data.*', this[onPropsChanged])
    }

    /**
    * Lifecycle callback handler triggered when data-binding initialization is complete.
    */
    ready() {
      super.ready();
      this.setAttribute('hidden', '')
    }

    /**
    * Property observer triggered if constraints or data are modified.
    */
    [onPropsChanged](constraints, data) {
      if (!(constraints.value && data.value)) return
      if (this.autoValidate === false) return
      this[debounce]('validate', this.validate, this.delay || 0)
    }

    /**
    * Validates the current data against the constraints, and sets the errors property with the results.
    */
    validate() {
      const options = {
        format: (this.format) ? this.format : 'grouped'
      }

      const errors = validate(this.data, this.constraints, options)

      this.set('errors', errors)
      this[fire]('validated', errors)

      return errors
    }
  }

  customElements.define(NebulaValidate.is, NebulaValidate)

}())
</script>